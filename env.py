import gymnasium as gym
from gymnasium import spaces
import numpy as np
from time import time as gettime

import sympy

class Player(gym.Env):
    """
    Plays the levels generated by the Generator to validate them
    """

    def __init__(self, size=5, preset_level=None):
        self.size = size
        self.preset_level = preset_level
        self.prime_percent = 0.3
        self.prime_range = self.max = 5

        self.observation_space = spaces.Dict({
            "board": spaces.Box(0, 100, shape=(self.size, self.size), dtype=int),
            "player_pos": spaces.Box(0, self.size, shape=(2,), dtype=int),
            "current_number": spaces.Discrete(100),
            "lives": spaces.Box(0, 10, shape=(1,), dtype=int),
            "remaining_number_of_primes": spaces.Discrete(int(self.prime_percent * (self.size * self.size))+1),
            "remaining_primes": spaces.Box(0, 10, shape=(int(self.prime_percent * (self.size * self.size)),), dtype=int),
            "time": spaces.Discrete(300)
        })

        self.action_space = spaces.Discrete(5)

    def _get_obs(self):
        return {
            "board": self.board,
            "player_pos": self.player_pos,
            "current_number": self.current_number,
            "remaining_number_of_primes": self.remaining_number_of_primes,
            "remaining_primes": self.remaining_primes,
            "lives": self.remaining_lives,
            "time": self.time_spent
        }

    def reset(
            self,
            seed=None,
            options=None,
    ):
        self.board, self.remaining_primes = self.gen_board()
        self.player_pos = np.array([0, 0])  # X, Y
        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
        self.remaining_number_of_primes = int(self.size * self.size * self.prime_percent)
        self.remaining_lives = 10
        self.time_spent = 0
        self.start_time = int(gettime())

        observation = self._get_obs()
        info = {}

        return observation, info

    def step(self, action):
        """
        Rewards need to tie in time, lives, whether the level is won or lost and whether
        the number eaten is good or bad
        """
        if action == 0 and self.player_pos[1] < 4:
            self.player_pos[1] += 1
        elif action == 1 and self.player_pos[1] > 0:
            self.player_pos[1] -= 1
        elif action == 2:
            self.eat()
        elif action == 3 and self.player_pos[0] < 4:
            self.player_pos[0] += 1
        elif action == 4 and self.player_pos[0] > 0:
            self.player_pos[0] -= 1

        self.render()

        self.time_spent = int(gettime() - self.start_time)
        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]

        if not self.remaining_number_of_primes and self.max != 100:
          self.max += 5

        if self.remaining_lives == 0:
          self.max = 5

        total_reward = self.calculate_rewards(action)
        terminated = not self.remaining_lives or not self.remaining_number_of_primes or self.time_spent == 300
        obs = self._get_obs()
        info = {}
        return obs, total_reward, terminated, False, info

    def gen_board(self):
        prime_numbers = list(sympy.primerange(1, self.prime_range + 1))

        possible_non_primes = np.arange(1, self.max)
        non_prime_numbers = possible_non_primes[~np.isin(possible_non_primes, prime_numbers)]

        number_of_primes = int(self.prime_percent * (self.size * self.size))
        prime_cells = np.random.choice(prime_numbers, number_of_primes, replace=True)

        number_of_non_primes = (self.size * self.size) - number_of_primes
        non_prime_cells = np.random.choice(non_prime_numbers, number_of_non_primes, replace=True)

        board = np.append(prime_cells, non_prime_cells)
        np.random.shuffle(board)
        board = np.reshape(board, (self.size, self.size))
        return board, prime_cells

    def eat(self):
        if self.current_number in self.remaining_primes:
            self.was_prime = True
            self.remaining_number_of_primes -= 1
        else:
            self.was_prime = False
            self.remaining_lives -= 1

        self.board[self.player_pos[0]][self.player_pos[1]] = 0

    def calculate_rewards(self, action):
        total_reward = + 0.2 * self.remaining_lives - 0.1 * self.time_spent
        if action == 2:
            total_reward += - 0.8 * (not self.was_prime) + - 0.5 * self.was_prime
        else:
            total_reward += - 1 * (not self.remaining_lives) + 1 * (not self.remaining_number_of_primes)

        return total_reward

    def render(self):
      pass

