import gymnasium as gym
from gymnasium import spaces
import numpy as np
from time import time as gettime

import sympy

class Player(gym.Env):
    """
    Plays the levels generated by the Generator to validate them
    """

    def __init__(self, size=5, preset_level=None):
        self.size = size
        self.preset_level = preset_level
        self.prime_percent = 0.3
        self.prime_range = self.max = 5

        self.observation_space = spaces.Dict({
            "board": spaces.Box(0, 100, shape=(self.size, self.size), dtype=int),
            "player_pos": spaces.Box(0, self.size, shape=(2,), dtype=int),
            "current_number": spaces.Discrete(100),
            "lives": spaces.Box(0, 10, shape=(1,), dtype=int),
            "remaining_number_of_primes": spaces.Discrete(int(self.prime_percent * (self.size * self.size))+1),
            "remaining_primes": spaces.Box(0, 10, shape=(int(self.prime_percent * (self.size * self.size)),), dtype=int),
            "time": spaces.Discrete(300)
        })

        self.action_space = spaces.Discrete(5)

    def _get_obs(self):
        return {
            "board": self.board,
            "player_pos": self.player_pos,
            "current_number": self.current_number,
            "remaining_number_of_primes": self.remaining_number_of_primes,
            "remaining_primes": self.remaining_primes,
            "lives": self.remaining_lives,
            "time": self.time_spent
        }

    def reset(
            self,
            seed=None,
            options=None,
    ):
        self.board, self.remaining_primes = self.gen_board()
        self.player_pos = np.array([0, 0])  # X, Y
        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]
        self.remaining_number_of_primes = int(self.size * self.size * self.prime_percent)
        self.remaining_lives = 10
        self.time_spent = 0
        self.start_time = int(gettime())

        observation = self._get_obs()
        info = {}

        return observation, info

    def step(self, action):
        """
        Rewards need to tie in time, lives, whether the level is won or lost and whether
        the number eaten is good or bad
        """
        if action == 0 and self.player_pos[1] < 4:
            self.player_pos[1] += 1
        elif action == 1 and self.player_pos[1] > 0:
            self.player_pos[1] -= 1
        elif action == 2:
            self.eat()
        elif action == 3 and self.player_pos[0] < 4:
            self.player_pos[0] += 1
        elif action == 4 and self.player_pos[0] > 0:
            self.player_pos[0] -= 1

        self.render()

        self.time_spent = int(gettime() - self.start_time)
        self.current_number = self.board[self.player_pos[0]][self.player_pos[1]]

        if not self.remaining_number_of_primes and self.max != 100:
          self.max += 5

        if self.remaining_lives == 0:
          self.max = 5

        total_reward = self.calculate_rewards(action)
        terminated = not self.remaining_lives or not self.remaining_number_of_primes or self.time_spent == 300
        obs = self._get_obs()
        info = {}
        return obs, total_reward, terminated, False, info

    def gen_board(self):
        prime_numbers = list(sympy.primerange(1, self.prime_range + 1))

        possible_non_primes = np.arange(1, self.max)
        non_prime_numbers = possible_non_primes[~np.isin(possible_non_primes, prime_numbers)]

        number_of_primes = int(self.prime_percent * (self.size * self.size))
        prime_cells = np.random.choice(prime_numbers, number_of_primes, replace=True)

        number_of_non_primes = (self.size * self.size) - number_of_primes
        non_prime_cells = np.random.choice(non_prime_numbers, number_of_non_primes, replace=True)

        board = np.append(prime_cells, non_prime_cells)
        np.random.shuffle(board)
        board = np.reshape(board, (self.size, self.size))
        return board, prime_cells

    def eat(self):
        if self.current_number in self.remaining_primes:
            self.was_prime = True
            self.remaining_number_of_primes -= 1
        else:
            self.was_prime = False
            self.remaining_lives -= 1

        self.board[self.player_pos[0]][self.player_pos[1]] = 0

    def calculate_rewards(self, action):
        total_reward = + 0.2 * self.remaining_lives - 0.1 * self.time_spent
        if action == 2:
            total_reward += - 0.8 * (not self.was_prime) + - 0.5 * self.was_prime
        else:
            total_reward += - 1 * (not self.remaining_lives) + 1 * (not self.remaining_number_of_primes)

        return total_reward

    def render(self):
      # env = Player(render=True)
      # state, info = env.reset()
      # print(state)
      # done = False
      
      # while not done:
      #     action = model.predict(state)
      #     state, reward, done, clipped, info = env.step(action)


      # print(f"Remaining Lives: {self.remaining_lives}, Remaining Primes: {self.remaining_number_of_primes}, "
      #       f"Time Spent: {self.time_spent}")
      # Initialize Pygame
      # pygame.init()
      # clock = pygame.time.Clock()
      #
      # # Constants
      # SCREEN_WIDTH = 400
      # SCREEN_HEIGHT = 400
      # CELL_SIZE = SCREEN_WIDTH // 5
      # AGENT_COLOR = (255, 0, 0)
      # BOARD_COLOR = (200, 200, 200)
      # FONT_SIZE = 30
      #
      # screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
      # pygame.display.set_caption("Number Muncher")
      #
      # for i in range(5):
      #     for j in range(5):
      #         pygame.draw.rect(screen, BOARD_COLOR, (j * CELL_SIZE, i * CELL_SIZE, CELL_SIZE, CELL_SIZE), 0)
      #         font = pygame.font.Font(None, FONT_SIZE)
      #         number_text = font.render(str(self.board[i, j]), True, (0, 0, 0))
      #         screen.blit(number_text, (j * CELL_SIZE + CELL_SIZE // 3, i * CELL_SIZE + CELL_SIZE // 3))
      #
      # # Draw the agent
      # agent_rect = pygame.Rect(self.player_pos[1] * CELL_SIZE, self.player_pos[0] * CELL_SIZE, CELL_SIZE, CELL_SIZE)
      # pygame.draw.rect(screen, AGENT_COLOR, agent_rect)
      #
      # pygame.display.flip()
      # clock.tick(4)
      
      pass
